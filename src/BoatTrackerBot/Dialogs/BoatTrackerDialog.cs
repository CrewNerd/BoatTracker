using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

using BoatTracker.BookedScheduler;
using BoatTracker.Bot.Configuration;
using BoatTracker.Bot.DataObjects;
using BoatTracker.Bot.Utils;

using Microsoft.ApplicationInsights;
using Microsoft.Bot.Builder.Dialogs;
using Microsoft.Bot.Builder.FormFlow;
using Microsoft.Bot.Builder.Luis;
using Microsoft.Bot.Builder.Luis.Models;
using Microsoft.Bot.Connector;

using Newtonsoft.Json.Linq;

namespace BoatTracker.Bot
{
    [Serializable]
    public class BoatTrackerDialog : LuisDialog<object>
    {
        [NonSerialized]
        private UserState currentUserState;

        [NonSerialized]
        private ChannelInfo currentChannelInfo;

        [NonSerialized]
        private TelemetryClient telemetryClient;

        private BookedSchedulerClient cachedClient;

        private string pendingReservationToCancel;

        private List<string> pendingReservationsToCancel;

        public BoatTrackerDialog(ILuisService service)
            : base(service)
        {
        }

        private TelemetryClient TelemetryClient
        {
            get
            {
                if (this.telemetryClient == null)
                {
                    this.telemetryClient = new TelemetryClient();
                }

                return this.telemetryClient;
            }
        }

        #region Intents

        [LuisIntent("")]
        public async Task None(IDialogContext context, LuisResult result)
        {
            if (result.Query.StartsWith("#!"))
            {
                string command = result.Query.Substring(2);

                this.TelemetryClient.TrackEvent("ControlMessage", new Dictionary<string, string> { ["Command"] = command });

                await this.ProcessControlMessage(context, command);
                context.Wait(this.MessageReceived);
                return;
            }

            // We special-case "quit" since it's how we bail out of forms. If the user
            // is logged out, we don't want a "quit" to trigger the login dialog.
            if (result.Query.Equals("quit", StringComparison.OrdinalIgnoreCase))
            {
                await context.PostAsync("Okay");
                context.Wait(this.MessageReceived);
                return;
            }

            if (!this.CheckUserIsRegistered(context)) { return; }

            this.TrackIntent(context, nameof(this.None));

            bool forceHelp = result.Query.ToLower().Contains("help") || result.Query.Equals("?");

            if (forceHelp || !this.currentUserState.HelpMessageShown)
            {
                await this.ShowHelpMessage(context);
            }
            else
            {
                string message = "I'm sorry, I don't understand. Enter '?' to see what you can say at any time.";
                await context.PostAsync(message);
            }

            context.Wait(this.MessageReceived);
        }

        private async Task ProcessControlMessage(IDialogContext context, string msg)
        {
            Func<Task> help = async () =>
            {
                await context.PostAsync("refreshcache [club id] - refresh the cache of BookedScheduler data");
            };

            if (msg.StartsWith("refreshcache"))
            {
                var args = msg.Split(' ');
                var clubId = args.Length > 1 ? args[1] : null;

                try
                {
                    await BookedSchedulerCache.Instance.RefreshCacheAsync(clubId);
                    await context.PostAsync("Cache refresh complete");
                }
                catch (Exception ex)
                {
                    await context.PostAsync($"Cache refresh failed: {ex.Message}");
                }
            }
            else if (msg.Equals("logout"))
            {
                context.UserData.Clear();
                await context.FlushAsync(CancellationToken.None);

                await context.PostAsync("Okay, by the time you read this it will be just like we've never met :) Say anything to start the sign-in process all over again.");
            }
            else if (msg.StartsWith("CancelReservation "))
            {
                //
                // This command is generated by the buttons we produce when the user wants
                // to cancel a reservation and their intent specifies multiple possibilities.
                //
                if (!this.CheckUserIsRegistered(context)) { return; }

                string referenceNumber = msg.Split(' ')[1];

                var client = await this.GetClient();
                try
                {
                    await client.DeleteReservationAsync(referenceNumber);
                    await context.PostAsync("Okay, your reservation is cancelled!");
                }
                catch (Exception)
                {
                    await context.PostAsync("I'm sorry, but I couldn't cancel your reservation. Please try again later.");
                }
            }
            else if (msg == "help")
            {
                await help.Invoke();
            }
            else
            {
                await context.PostAsync($"Unrecognized command: {msg}");
                await help.Invoke();
            }
        }

        [LuisIntent(nameof(ResetAccount))]
        public async Task ResetAccount(IDialogContext context, LuisResult result)
        {
            this.TrackIntent(context, nameof(this.ResetAccount));

            context.UserData.Clear();
            await context.FlushAsync(CancellationToken.None);

            await context.PostAsync("Okay, by the time you read this it will be just like we've never met :) Say anything to start the sign-in process all over again.");
            context.Wait(this.MessageReceived);
        }

        [LuisIntent(nameof(CreateReservation))]
        public async Task CreateReservation(IDialogContext context, LuisResult result)
        {
            if (!this.CheckUserIsRegistered(context)) { return; }

            this.TrackIntent(context, nameof(this.CreateReservation));

            result.FixEntities();
            var boatMatch = await this.currentUserState.FindBestResourceMatchAsync(result);
            var boatName = boatMatch?.Item1?.Name();
            var partnerMatch = await this.currentUserState.FindBestUserMatchAsync(result);
            var startDate = result.FindStartDate(this.currentUserState);
            var startTime = result.FindStartTime(this.currentUserState);
            var duration = result.FindDuration();

            ReservationRequest reservationRequest = new ReservationRequest
            {
                UserState = this.currentUserState,
                BoatName = boatName,
                PartnerUserId = partnerMatch.Item1?.Id(),
                PartnerName = partnerMatch.Item1?.FullName(),

                StartDate = startDate,
                OriginalStartDate = startDate,

                StartTime = startTime,
                OriginalStartTime = startTime
            };

            if (duration.HasValue)
            {
                reservationRequest.RawDuration = duration.Value;
            }

            if (boatMatch != null && boatMatch.Item1 == null)
            {
                await context.PostAsync(boatMatch.Item2);
            }

            if (boatMatch?.Item1 != null && !await this.currentUserState.HasPermissionForResourceAsync(boatMatch.Item1))
            {
                await context.PostAsync($"I'm sorry, but you don't have permission to use the {boatName}.");
            }

            if (boatMatch?.Item1 != null && !boatMatch.Item1.IsAvailable())
            {
                await context.PostAsync($"I'm sorry, but the {boatName} is currently unavailable for use.");
            }

            if (result.ContainsUserNameEntity() && partnerMatch.Item1 == null)
            {
                await context.PostAsync(partnerMatch.Item2);
            }

            if (boatMatch?.Item1 != null &&
                partnerMatch.Item1 != null &&
                !await this.currentUserState.HasPermissionForResourceAsync(boatMatch.Item1, partnerMatch.Item1.Id())
                )
            {
                await context.PostAsync($"I'm sorry, but {partnerMatch.Item1.FullName()} doesn't have permission to use the {boatName}.");
            }

            var reservationForm = new FormDialog<ReservationRequest>(reservationRequest, ReservationRequest.BuildForm, FormOptions.PromptInStart, result.Entities);
            context.Call(reservationForm, this.ReservationComplete);
        }

        private async Task ReservationComplete(IDialogContext context, IAwaitable<ReservationRequest> result)
        {
            if (!this.CheckUserIsRegistered(context)) { return; }

            ReservationRequest request = null;

            try
            {
                request = await result;
            }
            catch (FormCanceledException)
            {
                await context.PostAsync("Okay, I'm aborting your reservation request.");
                context.Wait(this.MessageReceived);
                return;
            }

            if (request != null)
            {
                DateTimeOffset start = new DateTimeOffset(request.StartDateTime.Value, this.currentUserState.LocalOffsetForDate(request.StartDateTime.Value));

                var client = await this.GetClient();

                try
                {
                    JToken boat = await BookedSchedulerCache.Instance[this.currentUserState.ClubId].GetResourceFromIdAsync(request.BoatId);

                    if (boat == null)
                    {
                        // BUG: Not sure why this would ever be necessary... it may be a relic.
                        boat = (await this.currentUserState.FindBestResourceMatchAsync(request.BoatName)).Item1;
                    }

                    var reservation = await client.CreateReservationAsync(boat, this.currentUserState.UserId, start, request.RawDuration, $"Practice in the {request.BoatName}", $"Created by BoatTracker Bot", request.PartnerUserId);

                    if (request.CheckInAfterCreation)
                    {
                        // TODO: Handle partial success here...
                        var response = await client.CheckInReservationAsync(reservation.ReferenceNumber());
                        var updatedReservation = await client.GetReservationAsync(reservation.ReferenceNumber());
                        var endTime = this.currentUserState.ConvertToLocalTime(updatedReservation.EndDate());
                        await context.PostAsync($"Okay, you're checked in and clear to go. Your reservation ends at {endTime.ToShortTimeString()}. Be sure to text 'done rowing' when you get back."); 
                    }
                    else
                    {
                        // TODO: Consider shortening this message after the user has seen it a few times.
                        await context.PostAsync(
                            "Okay, you're all set! When it's time for your reservation, just say 'rowing' to sign in. " +
                            $"You can sign in up to {this.currentUserState.ClubInfo().EarlyCheckinWindowInMinutes ?? 5} minutes before your reservation time.");
                    }
                }
                catch (Exception ex)
                {
                    await context.PostAsync($"I'm sorry, but the reservation system rejected your request. {ex.Message}");
                }
            }
            else
            {
                await context.PostAsync("ERROR: Form returned an empty response!!");
            }

            context.Wait(this.MessageReceived);
        }

        [LuisIntent(nameof(ListBoats))]
        public async Task ListBoats(IDialogContext context, LuisResult result)
        {
            if (!this.CheckUserIsRegistered(context)) { return; }

            this.TrackIntent(context, nameof(this.ListBoats));

            result.FixEntities();

            var resources = await BookedSchedulerCache.Instance[this.currentUserState.ClubId].GetResourcesAsync();

            var usableResources = resources.Where(boat => this.currentUserState.HasPermissionForResourceAsync(boat).Result);

            var capacity = result.BoatCapacity();
            var boatClass = "boat(s)";

            //
            // If the user specified a boat class, filter based on that.
            //
            if (capacity.HasValue)
            {
                usableResources = usableResources.Where(boat => boat.MaxParticipants() == capacity.Value);

                switch (capacity.Value)
                {
                    case 1:
                        boatClass = "single(s)";
                        break;
                    case 2:
                        boatClass = "double(s)";
                        break;
                    default:
                        break;
                }
            }

            if (usableResources.Count() > 0)
            {
                await context.PostAsync($"You have permission to use the following {boatClass}:");
                await context.PostAsync(string.Join(", ", usableResources.Select(b => b.Name()).ToArray()));
            }
            else
            {
                await context.PostAsync("You don't have permission to use any boats, currently.");
            }

            context.Wait(this.MessageReceived);
        }

        [LuisIntent(nameof(CheckBoatAvailability))]
        public async Task CheckBoatAvailability(IDialogContext context, LuisResult result)
        {
            if (!this.CheckUserIsRegistered(context)) { return; }

            this.TrackIntent(context, nameof(this.CheckBoatAvailability));

            result.FixEntities();
            //
            // Check for (and apply) a boat name filter
            //
            var boatMatch = await this.currentUserState.FindBestResourceMatchAsync(result);

            if (boatMatch != null && boatMatch.Item1 == null)
            {
                await context.PostAsync(boatMatch.Item2);
                context.Wait(this.MessageReceived);
                return;
            }

            if (boatMatch?.Item1 != null && !await this.currentUserState.HasPermissionForResourceAsync(boatMatch.Item1))
            {
                await context.PostAsync($"I'm sorry, but you don't have permission to use the {boatMatch.Item1.Name()}.");
                context.Wait(this.MessageReceived);
                return;
            }

            var client = await this.GetClient();

            IList<JToken> reservations = null;
            string filterDescription = string.Empty;

            if (boatMatch?.Item1 != null)
            {
                reservations = (await client.GetReservationsAsync(resourceId: boatMatch.Item1.ResourceId())).ToList();

                filterDescription += $" for the {boatMatch.Item1.Name()}";
            }
            else
            {
                reservations = (await client.GetReservationsAsync()).ToList();

                //
                // If we didn't get a specific boat name, check to see if they want to filter by type
                //
                var capacity = result.BoatCapacity();

                if (capacity.HasValue)
                {
                    reservations = reservations
                        .Where(r =>
                        {
                            var boat = BookedSchedulerCache.Instance[this.currentUserState.ClubId].GetResourceFromIdAsync(r.ResourceId()).Result;
                            return boat.MaxParticipants() == capacity.Value;
                        })
                        .ToList();

                    var boatClass = capacity.Value == 1 ? "singles" : "doubles";

                    filterDescription += $" for {boatClass}";
                }
            }

            var startDate = result.FindStartDate(this.currentUserState);

            bool showDate = true;

            if (startDate.HasValue)
            {
                reservations = reservations
                    .Where(r =>
                    {
                        var rStartDate = this.currentUserState.ConvertToLocalTime(r.StartDate());
                        return rStartDate.DayOfYear == startDate.Value.DayOfYear;
                    })
                    .ToList();

                filterDescription += $" on {startDate.Value.ToShortDateString()}";
                showDate = false;
            }

            // Finally, filter out boats that the user doesn't have permission to use.
            for (int i = reservations.Count - 1; i >= 0; i--)
            {
                JToken res = await BookedSchedulerCache.Instance[this.currentUserState.ClubId].GetResourceFromIdAsync(reservations[i].ResourceId());

                if (!await this.currentUserState.HasPermissionForResourceAsync(res))
                {
                    reservations.RemoveAt(i);
                }
            }

            if (reservations.Count == 0)
            {
                await context.PostAsync($"I don't see any reservations{filterDescription}, currently.");
            }
            else
            {
                string reservationDescription = await this.currentUserState.DescribeReservationsAsync(
                    reservations,
                    showOwner: true,
                    showDate: showDate,
                    useMarkdown: this.currentChannelInfo.SupportsMarkdown);

                await context.PostAsync($"I found the following reservation{this.Pluralize(reservations.Count)}{filterDescription}:\n\n---{reservationDescription}");
            }

            context.Wait(this.MessageReceived);
        }

        [LuisIntent(nameof(TakeOut))]
        public async Task TakeOut(IDialogContext context, LuisResult result)
        {
            if (!this.CheckUserIsRegistered(context)) { return; }

            this.TrackIntent(context, nameof(this.TakeOut));

            result.FixEntities();
            var boatMatch = await this.currentUserState.FindBestResourceMatchAsync(result);
            long? boatId = boatMatch?.Item1?.ResourceId();

            //
            // If they did provide a boat name, make sure they have permission
            //
            if (boatMatch?.Item1 != null)
            {
                // Check that the user even has permission for the boat.
                JToken res = await BookedSchedulerCache.Instance[this.currentUserState.ClubId].GetResourceFromIdAsync(boatId.Value);
                if (!await this.currentUserState.HasPermissionForResourceAsync(res))
                {
                    await context.PostAsync($"I'm sorry, but you don't have permission to use the {res.Name()}");
                    context.Wait(this.MessageReceived);
                    return;
                }
            }

            var localTime = this.currentUserState.LocalTime();
            var client = await this.GetClient();

            //
            // If the user did provide a boat name, we filter the reservations query based on that. Otherwise, just
            // look for any reservation near the current time.
            //
            var reservations = (await client.GetReservationsAsync(
                this.currentUserState.UserId,
                boatId,
                start: localTime - TimeSpan.FromHours(6)))
                .ToList();

            // Look for reservations starting within 15 minutes (plus or minus) of the current time that aren't already checked in.
            var qualifiedReservations = reservations
                .Where(r =>
                    localTime > this.currentUserState.ConvertToLocalTime(r.StartDate() - TimeSpan.FromMinutes(15)) &&
                    localTime < this.currentUserState.ConvertToLocalTime(r.StartDate() + TimeSpan.FromMinutes(15)) &&
                    r.CheckInDate() == null)
                .ToList();

            switch (qualifiedReservations.Count())
            {
                case 0:
                    // Handle the (common) case where there's no prior reservation.
                    await this.CreateReservationOnDemand(context, result, boatMatch?.Item1);
                    return;

                case 1:
                    try
                    {
                        var reservation = qualifiedReservations[0];
                        var response = await client.CheckInReservationAsync(reservation.ReferenceNumber());
                        var updatedReservation = await client.GetReservationAsync(reservation.ReferenceNumber());
                        var endTime = this.currentUserState.ConvertToLocalTime(reservation.EndDate());
                        await context.PostAsync($"Okay, you're all set to take out the {reservation.ResourceName()}. Your reservation ends at {endTime.ToShortTimeString()}. Be sure to text 'done rowing' when you return."); 
                    }
                    catch (Exception ex)
                    {
                        await context.PostAsync($"Sorry, but I couldn't check you in for the {qualifiedReservations[0].ResourceName()}. {ex.Message}");
                    }

                    break;

                default:
                    await context.PostAsync("It looks like you have more than one reservation starting about now. Can you be more specific?");
                    break;
            }

            context.Wait(this.MessageReceived);
        }

        private async Task CreateReservationOnDemand(IDialogContext context, LuisResult result, JToken boat)
        {
            //
            // Some requests look like "TakeOut" even though the user intended to create a
            // reservation. If we see a start time or date specified then effectively treat
            // this like CreateReservation.
            //
            var startDateEntity = result.FindStartDate(this.currentUserState);
            var startTimeEntity = result.FindStartTime(this.currentUserState);

            if (!startDateEntity.HasValue && !startTimeEntity.HasValue)
            {
                // If it looks like a true "TakeOut", then give them this feedback.
                await context.PostAsync("You don't have a reservation, but I can create one for you now.");
            }

            var boatName = boat?.Name();
            var now = this.currentUserState.LocalTime();
            var startTime = now.ToNearestTimeSlot();

            var partnerMatch = await this.currentUserState.FindBestUserMatchAsync(result);

            if (result.ContainsUserNameEntity() && partnerMatch?.Item2 != null)
            {
                await context.PostAsync(partnerMatch.Item2);
            }

            ReservationRequest reservationRequest;

            if (startDateEntity.HasValue || startTimeEntity.HasValue)
            {
                reservationRequest = new ReservationRequest
                {
                    CheckInAfterCreation = result.IsStartTimeNow(),
                    UserState = this.currentUserState,
                    BoatName = boatName,
                    PartnerName = partnerMatch.Item1?.FullName(),

                    // If they only gave us a new time, we let "today" be the default date.
                    StartDate = startDateEntity.HasValue ? startDateEntity.Value.Date : now.Date,
                    OriginalStartDate = startDateEntity.HasValue ? startDateEntity.Value.Date : now.Date,

                    StartTime = startTimeEntity,
                    OriginalStartTime = startTimeEntity
                };
            }
            else
            {
                //
                // In the normal TakeOut case, we use the current date/time.
                //
                reservationRequest = new ReservationRequest
                {
                    CheckInAfterCreation = true,
                    UserState = this.currentUserState,
                    BoatName = boatName,
                    PartnerName = partnerMatch.Item1?.FullName(),

                    StartDate = now.Date,
                    OriginalStartDate = now.Date,

                    StartTime = startTime,
                    OriginalStartTime = startTime
                };
            }

            var duration = result.FindDuration();
            if (duration.HasValue)
            {
                reservationRequest.RawDuration = duration.Value;
            }

            var reservationForm = new FormDialog<ReservationRequest>(reservationRequest, ReservationRequest.BuildForm, FormOptions.PromptInStart, result.Entities);
            context.Call(reservationForm, this.ReservationComplete);
        }

        [LuisIntent(nameof(Return))]
        public async Task Return(IDialogContext context, LuisResult result)
        {
            if (!this.CheckUserIsRegistered(context)) { return; }

            this.TrackIntent(context, nameof(this.Return));

            result.FixEntities();

            // Note: we don't require a boat name here. Normally, there will only be one
            // active reservation for the user and they can simply say "i'm done".

            var boatMatch = await this.currentUserState.FindBestResourceMatchAsync(result);
            long? boatId = boatMatch?.Item1?.ResourceId();

            var localTime = this.currentUserState.LocalTime();
            var client = await this.GetClient();

            var reservations = (await client.GetReservationsAsync(
                this.currentUserState.UserId,
                boatId,
                start: localTime - TimeSpan.FromHours(6)))
                .ToList();

            // Filter down to "current" reservations that haven't been checked-out yet.
            var qualifiedReservations = reservations
                .Where(r =>
                    r.CheckInDate() != null && r.CheckOutDate() == null &&
                    localTime > this.currentUserState.ConvertToLocalTime(r.StartDate()) &&
                    localTime < this.currentUserState.ConvertToLocalTime(r.EndDate() + TimeSpan.FromHours(1)))
                .ToList();

            switch (qualifiedReservations.Count())
            {
                case 0:
                    await context.PostAsync("Sorry, but I don't see a current (or recent) reservation for you to check out of at this time.");
                    break;

                case 1:
                    try
                    {
                        var response = await client.CheckOutReservationAsync(qualifiedReservations[0].ReferenceNumber());
                        var updatedReservation = await client.GetReservationAsync(qualifiedReservations[0].ReferenceNumber());
                        await context.PostAsync("Okay, you're good to go. Thanks!");
                    }
                    catch (Exception ex)
                    {
                        await context.PostAsync($"Sorry, but I couldn't check you out of your reservation. {ex.Message}");
                    }

                    break;

                default:
                    await context.PostAsync("It looks like you have more than one current or recent reservation that hasn't been closed out. Please try again and include the name of the boat.");
                    break;
            }

            context.Wait(this.MessageReceived);
        }

        [LuisIntent(nameof(CheckReservations))]
        public async Task CheckReservations(IDialogContext context, LuisResult result)
        {
            if (!this.CheckUserIsRegistered(context)) { return; }

            this.TrackIntent(context, nameof(this.CheckReservations));

            result.FixEntities();
            var client = await this.GetClient();

            var reservations = (await client.GetReservationsForUserAsync(this.currentUserState.UserId)).ToList();

            string filterDescription = string.Empty;

            //
            // Check for (and apply) a boat name filter
            //
            var boatMatch = await this.currentUserState.FindBestResourceMatchAsync(result);

            if (boatMatch?.Item1 != null)
            {
                reservations = reservations
                    .Where(r => r.ResourceId() == boatMatch.Item1.ResourceId())
                    .ToList();

                filterDescription = $" for the {boatMatch.Item1.Name()}";
            }
            else
            {
                filterDescription = " for you";
            }

            var startDate = result.FindStartDate(this.currentUserState);

            bool showDate = true;

            if (startDate.HasValue)
            {
                reservations = reservations
                    .Where(r =>
                    {
                        var rStartDate = this.currentUserState.ConvertToLocalTime(r.StartDate());
                        return rStartDate.DayOfYear == startDate.Value.DayOfYear;
                    })
                    .ToList();

                showDate = false;
                filterDescription += $" on {startDate.Value.ToShortDateString()}";
            }

            if (reservations.Count == 0)
            {
                await context.PostAsync($"I don't see any reservations{filterDescription}, currently.");
            }
            else
            {
                string reservationDescription = await this.currentUserState.DescribeReservationsAsync(
                    reservations,
                    showDate: showDate,
                    useMarkdown: this.currentChannelInfo.SupportsMarkdown);

                await context.PostAsync($"I found the following reservation{this.Pluralize(reservations.Count)}{filterDescription}:\n\n---{reservationDescription}");
            }

            context.Wait(this.MessageReceived);
        }

        [LuisIntent(nameof(CancelReservation))]
        public async Task CancelReservation(IDialogContext context, LuisResult result)
        {
            if (!this.CheckUserIsRegistered(context)) { return; }

            this.TrackIntent(context, nameof(this.CancelReservation));

            result.FixEntities();
            var client = await this.GetClient();

            var reservations = (await client.GetReservationsForUserAsync(this.currentUserState.UserId)).ToList();

            string filterDescription = string.Empty;

            //
            // Check for (and apply) a boat name filter
            //
            var boatMatch = await this.currentUserState.FindBestResourceMatchAsync(result);

            if (boatMatch?.Item1 != null)
            {
                reservations = reservations
                    .Where(r => r.ResourceId() == boatMatch.Item1.ResourceId())
                    .ToList();

                filterDescription = $" for the {boatMatch.Item1.Name()}";
            }
            else
            {
                filterDescription = " for you";
            }

            var startDate = result.FindStartDate(this.currentUserState);

            bool showDate = true;

            if (startDate.HasValue)
            {
                reservations = reservations
                    .Where(r =>
                    {
                        var rStartDate = this.currentUserState.ConvertToLocalTime(r.StartDate());
                        return rStartDate.DayOfYear == startDate.Value.DayOfYear;
                    })
                    .ToList();

                showDate = false;
                filterDescription += $" on {startDate.Value.ToShortDateString()}";
            }

            string reservationDescription;

            switch (reservations.Count)
            {
                case 0:
                    await context.PostAsync($"I don't see any reservations{filterDescription}.");
                    context.Wait(this.MessageReceived);
                    break;

                case 1:
                    //
                    // We found a single matching reservation, so just give the user a prompt
                    // to confirm that this is the one that they want to cancel.
                    //
                    reservationDescription = await this.currentUserState.DescribeReservationsAsync(
                        reservations,
                        showDate: showDate,
                        useMarkdown: this.currentChannelInfo.SupportsMarkdown);

                    this.pendingReservationToCancel = reservations[0].ReferenceNumber();

                    PromptDialog.Confirm(
                        context,
                        this.AfterConfirming_DeleteReservation,
                        $"Is this the reservation you want to cancel? (yes/no)\n\n---{reservationDescription}",
                        attempts: 3,
                        retry: "Sorry, I don't understand your response. Do you want to cancel the reservation shown above? (yes/no)",
                        promptStyle: PromptStyle.None);

                    break;

                default:
                    //
                    // We found multiple reservations matching the given criteria, so present
                    // them all and ask the user which one they want to cancel.
                    //
                    if (this.currentChannelInfo.SupportsButtons)
                    {
                        var response = context.MakeMessage();
                        List<CardAction> cardButtons = new List<CardAction>();

                        foreach (var reservation in reservations)
                        {
                            cardButtons.Add(new CardAction
                            {
                                Type = ActionTypes.ImBack,
                                Value = $"#!CancelReservation {reservation.ReferenceNumber()}",
                                Title = await this.currentUserState.SummarizeReservationAsync(reservation)
                            });
                        }

                        HeroCard card = new HeroCard()
                        {
                            Title = $"I found multiple reservations{filterDescription}",
                            Subtitle = "Please press the button for each reservation you want to cancel.",
                            Buttons = cardButtons
                        };

                        response.Attachments.Add(card.ToAttachment());

                        await context.PostAsync(response);
                        context.Wait(this.MessageReceived);
                    }
                    else
                    {
                        reservationDescription = await this.currentUserState.DescribeReservationsAsync(
                            reservations,
                            showDate: showDate,
                            showIndex: true,
                            useMarkdown: this.currentChannelInfo.SupportsMarkdown);

                        await context.PostAsync($"I found multiple reservations{filterDescription}:\n\n{reservationDescription}\n\n");

                        this.pendingReservationsToCancel = reservations.Select(r => r.ReferenceNumber()).ToList();

                        PromptDialog.Number(
                            context,
                            AfterSelectingReservation_DeleteReservation,
                            $"Please enter the number of the reservation you want to cancel, or {reservations.Count + 1} for 'none'.",
                            "I'm sorry, but that isn't a valid response. Please select one of the options listed above.",
                            3);
                    }

                    break;
            }
        }

        public async Task AfterConfirming_DeleteReservation(IDialogContext context, IAwaitable<bool> confirmation)
        {
            if (!this.CheckUserIsRegistered(context)) { return; }

            try
            {
                if (await confirmation)
                {
                    var client = await this.GetClient();
                    try
                    {
                        await client.DeleteReservationAsync(this.pendingReservationToCancel);
                        await context.PostAsync("Okay, your reservation is cancelled!");
                    }
                    catch (Exception)
                    {
                        await context.PostAsync("I'm sorry, but I couldn't cancel your reservation. Please try again later.");
                    }
                }
                else
                {
                    await context.PostAsync("Okay, your reservation is unchanged.");
                }
            }
            catch (TooManyAttemptsException)
            {
                await context.PostAsync("Sorry, I don't understand that. I'm leaving your reservation unchanged.");
            }

            context.Wait(this.MessageReceived);
        }

        public async Task AfterSelectingReservation_DeleteReservation(IDialogContext context, IAwaitable<long> confirmation)
        {
            if (!this.CheckUserIsRegistered(context)) { return; }

            try
            {
                long index = await confirmation - 1;

                if (index >= 0 && index < this.pendingReservationsToCancel.Count)
                {
                    var client = await this.GetClient();
                    try
                    {
                        await client.DeleteReservationAsync(this.pendingReservationsToCancel[(int)index]);
                        await context.PostAsync("Okay, that reservation is cancelled now!");
                    }
                    catch (Exception)
                    {
                        await context.PostAsync("I'm sorry, but I couldn't cancel your reservation. Please try again later.");
                    }
                }
                else if (index == this.pendingReservationsToCancel.Count)
                {
                    await context.PostAsync("Okay, I'm leaving all of your reservations unchanged.");
                }
                else
                {
                    await context.PostAsync("The index you entered is invalid, so no reservation was cancelled.");
                }
            }
            catch (TooManyAttemptsException)
            {
                await context.PostAsync("Since you didn't select one of the listed options, I'm leaving all of your reservations unchanged.");
            }

            this.pendingReservationsToCancel = null;
            context.Wait(this.MessageReceived);
        }

#endregion

#region Misc Helpers

        /// <summary>
        /// Checks to see if the user has signed into the bot previously. If so, set the currentUserState
        /// and return success. Otherwise, kick off the sign-in process.
        /// </summary>
        /// <param name="context">The caller's dialog context</param>
        /// <returns>True if the user accounts are connected, false otherwise.</returns>
        private bool CheckUserIsRegistered(IDialogContext context)
        {
            this.currentChannelInfo = EnvironmentDefinition.Instance.GetChannelInfo(context.GetChannel());

            if (this.currentChannelInfo == null)
            {
                context.PostAsync("This channel is not currently supported.").Wait();
                return false;
            }

            UserState userState = null;

            //
            // Make sure we have state for the user that contains everything we need.
            //
            if (context.UserData.TryGetValue(UserState.PropertyName, out userState))
            {
                if (userState.IsComplete)
                {
                    // The user is fully registered
                    this.currentUserState = userState;
                    return true;
                }
            }

            // The user isn't registered, so start the signin form to get the information we need to do that.
            // The current intent is aborted in favor of the sign-in flow.
            this.TrackIntent(context, "SignIn");
            var signInForm = new FormDialog<SignInForm>(new SignInForm(), SignInForm.BuildForm, FormOptions.PromptInStart);
            context.Call(signInForm, this.SignInComplete);
            return false;
        }

        private async Task SignInComplete(IDialogContext context, IAwaitable<SignInForm> result)
        {
            SignInForm signInForm;

            try
            {
                signInForm = await result;
            }
            catch (FormCanceledException)
            {
                await context.PostAsync("Okay, I'm aborting your sign-in. You can retry again later.");
                context.Wait(this.MessageReceived);
                return;
            }

            // Sign-in was successful. Now, attempt to update the user's profile to record the user key
            // in their profile under the appropriate channel name.
            var user = (await BookedSchedulerCache.Instance[signInForm.ClubInitials].GetUsersAsync())
                .Where(u => u.UserName() == signInForm.UserName)
                .FirstOrDefault();

            if (user == null)
            {
                await context.PostAsync("Unexpected error in the sign-in process - the user wasn't found after form completion.");
                context.Wait(this.MessageReceived);
                return;
            }

            var channelInfo = EnvironmentDefinition.Instance.GetChannelInfo(context.GetChannel());

            if (channelInfo == null)
            {
                await context.PostAsync("Unexpected error in the sign-in process - the channel wasn't found after form completion.");
                context.Wait(this.MessageReceived);
                return;
            }

            try
            {
                // Now finish populating the user state and persist it.
                UserState userState = new UserState
                {
                    ClubId = signInForm.ClubInitials,
                    UserId = user.Id()
                };

                context.UserData.SetValue(UserState.PropertyName, userState);
                this.currentUserState = userState;

                await context.PostAsync(
                    "Okay, your account is now initialized and you can begin using the BoatTracker " +
                    "Bot to create and manage your reservations. Type ? at any time to see what you can say.");
            }
            catch (Exception ex)
            {
                await context.PostAsync($"I'm sorry... I verified your identity but I wasn't able to connect your {channelInfo.DisplayName} account to the reservation system. Please try again later. ({ex.Message})");
            }

            context.Wait(this.MessageReceived);
        }

        private void TrackIntent(IDialogContext context, string intent)
        {
            this.TelemetryClient.TrackEvent(
                intent,
                new Dictionary<string, string>
                {
                    ["ClubId"] = this.currentUserState != null ? this.currentUserState.ClubId : "Unknown",
                    ["Channel"] = context.GetChannel()
                });
        }

        /// <summary>
        /// Gets a client object for the user's BookedScheduler instance. These are cached and reused.
        /// </summary>
        /// <returns>A BookedSchedulerClient instance that is signed in and ready for use.</returns>
        private async Task<BookedSchedulerClient> GetClient()
        {
            var clubInfo = EnvironmentDefinition.Instance.MapClubIdToClubInfo[this.currentUserState.ClubId];

            if (this.cachedClient == null)
            {
                this.cachedClient = new BookedSchedulerRetryClient(this.currentUserState.ClubId, true);
            }

            if (!this.cachedClient.IsSignedIn || this.cachedClient.IsSessionExpired)
            {
                await this.cachedClient.SignInAsync(clubInfo.UserName, clubInfo.Password);
            }

            return this.cachedClient;
        }

        private async Task ShowHelpMessage(IDialogContext context)
        {
            await context.PostAsync(
                "I can help you with:\n\n" +
                "## Listing all boats\n\n" +
                "* What boats can I use?\n" +
                "* What singles can I use?\n\n" +
                "## Checking the availability of a boat\n\n" +
                "* Is the Little Thunder available on Thursday?\n" +
                "* What doubles are free tomorrow?\n\n" +
                "## Creating a reservation\n\n" +
                "* Reserve the Little Thunder on Thursday at 5am for 2 hours\n\n" +
                "## Canceling a reservation\n\n" +
                "* Cancel my reservation for the Little Thunder\n\n" +
                "## Reviewing reservations\n\n" +
                "* Show my reservations\n" +
                "* Did I reserve the Little Thunder?\n" +
                "* Show my reservation for the Little Thunder on Friday\n\n" +
                "## Taking out a boat\n\n" +
                "* Take out the Little Thunder for two hours\n\n" +
                "## Returning a boat\n\n" +
                "* Return the Little Thunder");

            this.currentUserState.HelpMessageShown = true;
            context.UserData.SetValue(UserState.PropertyName, this.currentUserState);
        }

        private string Pluralize(int count)
        {
            return count > 1 ? "s" : string.Empty;
        }

#endregion
    }
}